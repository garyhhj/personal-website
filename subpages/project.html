
<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="description" content="personal website by yarh">
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title> Projects </title>
    <link rel="stylesheet" href="subpageStyle.css"> 
    <link rel="icon" type="image/x-icon" href="../image/favicon.ico">

    <!-- <script src="source.js" defer> </script> -->
  </head>
  <body class="loadingAnimation">
    <h1> Projects </h1>
    <div class="contentWrapper"> 

        <!-- chess engine -->
        <a class="projectTitleLink" href="https://github.com/garyhhj/chess-engine-v2"> <strong> Chess Engine </strong> </a>
        <p class="paragraphDescription"> 
            This is by far the most challenging project I have worked on. I dislike losing in chess so I wrote a chess engine that could 
            play better than me. It finds chess moves that I would never be able to find, especially in a game situation. It has a playing 
            strength of ~1500elo and has beaten 2000 rated chess bots on 
            <a class="paragraphLink" href="https://www.chess.com/"> chess.com</a>. A demo of this 
            chess engine can be seen in the <a class="paragraphLink" href="https://github.com/garyhhj/chess-engine-v2"> readme</a>.  
        </p>

        <p class="paragraphDescription"> 
            I used C/C++ to write this chess engine. What impressed me while researching this project is the amount of dedication that the
            chess programming community has put into finding optimization techniques. The explainations on 
            <a class="paragraphLink" href="https://www.chessprogramming.org/Main_Page"> Chess Programming Wiki</a> as well as posts 
            about world's fastest chess move generator on 
            <a class="paragraphLink" href="https://www.codeproject.com/Articles/5313417/Worlds-Fastest-Bitboard-Chess-Movegenerator"> 
            code project</a> helped me understand many of these optimization techniques for tree prunning and bit manipulation. 
        </p class="paragraphDescription">

        <!-- pathfinding visualizer -->
        <a class="projectTitleLink" href="https://github.com/garyhhj/pathfinding-visualizer"> <strong> Pathfinding Visualizer </strong> </a>
        <p class="paragraphDescription">
            When I first started programming, I was introduced to competitive programming by my friends and started doing problems on 
            <a class="paragraphLink" href="https://dmoj.ca/user/yarh">DMOJ</a>. While solving these problems, I learned many algorithms. After 
            writing Dijkstra for the nth time, I thought it would be cool to create a visualizer for this algorithm.      
        </p>

        <p class="paragraphDescription"> 
            My favorite part about this project is watching the pathfinding algorithm(Dijkstra or A*) find their way from a 
            starting point to an ending point in a maze. A demo of this project can be found in my github's 
            <a class="paragraphLink" href="https://github.com/garyhhj/pathfinding-visualizer">readme</a>.
        </p>

        <!-- sorting visualizer -->
        <a class="projectTitleLink" href="https://github.com/garyhhj/sorting-visualizer"> <strong> Sorting Visualizer </strong> </a>
        <p class="paragraphDescription">
            After seeing this <a class="paragraphLink" href="https://www.youtube.com/watch?v=kPRA0W1kECg">video</a> about different 
            sorting algorithm, I knew I needed to create my own version. 
        </p>

        <p class="paragraphDescription">
            Researching for this project not only taught me about 
            <a class="paragraphLink" href="https://en.wikipedia.org/wiki/Time_complexity">time complexity</a>
             and
             <a class="paragraphLink" href="https://en.wikipedia.org/wiki/Space_complexity">space complexity</a>
             of different sorting algorithms but also that different 
            algorithms may run faster or slower on "specific data", like 
            <a class="paragraphLink" href="https://en.wikipedia.org/wiki/K-sorted_sequence">almost sorted data</a>
             or reverse sorted data. A demo of this project can 
            be found in my github's <a class="paragraphLink" href="https://github.com/garyhhj/sorting-visualizer">readme</a>.
        </p>

        <!-- Chip8 Emulator -->
        <a class="projectTitleLink" href="https://github.com/garyhhj/chip8"> <strong> Chip8 Emulator </strong> </a>
        <p class="paragraphDescription">
            I always wondered how computers worked so I wrote a <a class="paragraphLink" href="https://en.wikipedia.org/wiki/CHIP-8"> chip8</a> 
            emulator to  help better my understanding. This project was very enjoyable to write and helped me improve my C++ skills. 
        </p>

        <a class="projectTitleLink" href="https://github.com/garyhhj/sudoku-solver"> <strong>  Sudoku Solver </strong> </a>
        <p class="paragraphDescription">
            I wrote a sudoku solver so I can solve sudoku as fast as the pros. What makes this sudoku solver faster than other sudoku solver 
            using the normal <a class="paragraphLink" href="https://en.wikipedia.org/wiki/Backtracking"> backtracking</a> 
            algorithm was that it greedily chooses the 3x3 square with the least number of options to reduce possible tree branching to search.  
        </p>

        <!-- insert first year programming project, make sure nes emulator is done so don't have to insert -->
    </div>

    <footer>
        <p class="footerContent">&copy;2025 Gary Huang</p>
    </footer>
</body>
</html>